
-- ==========================================
-- CORE SERVICES & DEPENDENCIES
-- ==========================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

-- ==========================================
-- UNIFIED CONFIGURATION SYSTEM
-- ==========================================
local Config = {
	-- Weapon Configuration
	WEAPONS = {},

	-- Security Configuration
	SECURITY = {
		-- Network Tolerance
		NETWORK_LATENCY_TOLERANCE = 0.05,
		MAX_PACKET_LOSS_TOLERANCE = 0.1,

		-- Rate Limiting
		MIN_FIRE_INTERVAL = 0.03,
		MIN_RELOAD_INTERVAL = 1.0,
		MIN_WEAPON_SWITCH_INTERVAL = 0.1,
		MIN_STATE_CHANGE_INTERVAL = 0.05,

		-- Validation Thresholds
		MAX_SHOT_DISTANCE = 7,
		MAX_AMMO_DISCREPANCY = 2,
		MAX_SPREAD_DEVIATION = 0.5,

		-- Behavioral Analysis
		MAX_ACCURACY_THRESHOLD = 0.85,
		MAX_HEADSHOT_RATIO = 0.70,
		MIN_REACTION_TIME = 0.08,
		MIN_MOVEMENT_VARIANCE = 0.02,

		-- Punishment System
		VIOLATION_DECAY_TIME = 300, -- 5 minutes
		WARNING_THRESHOLD = 5,
		TEMP_RESTRICT_THRESHOLD = 15,
		TEMP_BAN_THRESHOLD = 30,
		PERM_BAN_THRESHOLD = 50,

		-- Memory Management
		MAX_LOG_ENTRIES = 1000,
		MAX_HISTORY_LENGTH = 50,
		CLEANUP_INTERVAL = 300
	},

	-- Performance Configuration
	PERFORMANCE = {
		TICK_RATE = 60,
		MAX_CONCURRENT_VALIDATIONS = 100,
		BATCH_SIZE = 10,
		CACHE_EXPIRY = 30
	}
}

-- ==========================================
-- UNIFIED PLAYER MANAGER
-- ==========================================
local PlayerManager = {}
PlayerManager.__index = PlayerManager

function PlayerManager.new()
	local self = setmetatable({}, PlayerManager)
	self.players = {}
	self.eventBus = {}
	self.validationQueue = {}
	self.performanceMetrics = {
		validationsPerSecond = 0,
		memoryUsage = 0,
		lastCleanup = 0
	}

	self:_initializeEventBus()
	self:_startMainLoop()

	return self
end

function PlayerManager:_initializeEventBus()
	self.eventBus = {
		listeners = {},

		on = function(event, callback)
			if not self.eventBus.listeners[event] then
				self.eventBus.listeners[event] = {}
			end
			table.insert(self.eventBus.listeners[event], callback)
		end,

		emit = function(event, ...)
			local listeners = self.eventBus.listeners[event]
			if listeners then
				for _, callback in ipairs(listeners) do
					local success, err = pcall(callback, ...)
					if not success then
						warn(`[EventBus] Error in {event} listener: {err}`)
					end
				end
			end
		end
	}
end
-- ==========================================
-- MAIN LOOP IMPLEMENTATION FOR PLAYERMANAGER
-- ==========================================

function PlayerManager:_startMainLoop()
	-- Performance tracking variables
	local lastCleanup = 0
	local lastPerformanceReset = 0
	local validationCounter = 0

	-- Main loop connection
	self.mainLoopConnection = RunService.Heartbeat:Connect(function()
		local currentTime = os.clock()

		-- ==========================================
		-- PERFORMANCE METRICS TRACKING
		-- ==========================================
		validationCounter = validationCounter + 1

		-- Reset validation counter every second
		if currentTime - lastPerformanceReset >= 1.0 then
			self.performanceMetrics.validationsPerSecond = validationCounter
			validationCounter = 0
			lastPerformanceReset = currentTime

			-- Update memory usage estimate
			self.performanceMetrics.memoryUsage = self:_calculateMemoryUsage()
		end

		-- ==========================================
		-- PERIODIC CLEANUP (every 5 minutes)
		-- ==========================================
		if currentTime - lastCleanup >= Config.SECURITY.CLEANUP_INTERVAL then
			self:_performCleanup(currentTime)
			lastCleanup = currentTime
			self.performanceMetrics.lastCleanup = currentTime
		end

		-- ==========================================
		-- PLAYER DATA MAINTENANCE
		-- ==========================================
		self:_updatePlayerStates(currentTime)

		-- ==========================================
		-- VALIDATION QUEUE PROCESSING
		-- ==========================================
		self:_processValidationQueue()

		-- ==========================================
		-- SECURITY MONITORING
		-- ==========================================
		self:_monitorSecurityThreats(currentTime)
	end)
end

-- ==========================================
-- CLEANUP OPERATIONS
-- ==========================================
function PlayerManager:_performCleanup(currentTime)
	local cleanupCount = 0

	for player, playerData in pairs(self.players) do
		if not player.Parent then
			-- Player disconnected but not properly removed
			self:removePlayer(player)
			cleanupCount = cleanupCount + 1
			continue
		end

		-- Clean violation logs (keep only recent ones)
		local violations = playerData.security.violations
		local cutoffTime = currentTime - Config.SECURITY.VIOLATION_DECAY_TIME

		for i = #violations, 1, -1 do
			if violations[i].timestamp < cutoffTime then
				table.remove(violations, i)
				cleanupCount = cleanupCount + 1
			end
		end

		-- Limit violation log size
		if #violations > Config.SECURITY.MAX_LOG_ENTRIES then
			local excessCount = #violations - Config.SECURITY.MAX_LOG_ENTRIES
			for i = 1, excessCount do
				table.remove(violations, 1)
			end
			cleanupCount = cleanupCount + excessCount
		end

		-- Clean behavior history arrays
		local behavior = playerData.behavior

		-- Limit accuracy history
		if #behavior.accuracyHistory > Config.SECURITY.MAX_HISTORY_LENGTH then
			local excess = #behavior.accuracyHistory - Config.SECURITY.MAX_HISTORY_LENGTH
			for i = 1, excess do
				table.remove(behavior.accuracyHistory, 1)
			end
		end

		-- Limit reaction time history
		if #behavior.reactionTimes > Config.SECURITY.MAX_HISTORY_LENGTH then
			local excess = #behavior.reactionTimes - Config.SECURITY.MAX_HISTORY_LENGTH
			for i = 1, excess do
				table.remove(behavior.reactionTimes, 1)
			end
		end

		-- Limit movement data
		if #behavior.movementData > Config.SECURITY.MAX_HISTORY_LENGTH then
			local excess = #behavior.movementData - Config.SECURITY.MAX_HISTORY_LENGTH
			for i = 1, excess do
				table.remove(behavior.movementData, 1)
			end
		end

		-- Limit shot patterns
		if #behavior.shotPatterns > Config.SECURITY.MAX_HISTORY_LENGTH then
			local excess = #behavior.shotPatterns - Config.SECURITY.MAX_HISTORY_LENGTH
			for i = 1, excess do
				table.remove(behavior.shotPatterns, 1)
			end
		end

		-- Decay suspicion score over time
		local timeSinceLastViolation = currentTime - playerData.security.lastViolation
		if timeSinceLastViolation > Config.SECURITY.VIOLATION_DECAY_TIME then
			playerData.security.suspicionScore = math.max(0, 
				playerData.security.suspicionScore * 0.95) -- 5% decay per cleanup cycle
		end
	end

	-- Clean validation queue cache
	for key, cacheEntry in pairs(self.validationQueue) do
		if currentTime - cacheEntry.timestamp > Config.PERFORMANCE.CACHE_EXPIRY then
			self.validationQueue[key] = nil
			cleanupCount = cleanupCount + 1
		end
	end

	-- Emit cleanup event for monitoring
	self.eventBus.emit("cleanup", {
		timestamp = currentTime,
		itemsCleaned = cleanupCount,
		playerCount = self:getPlayerCount()
	})

	print(`[PlayerManager] Cleanup completed: {cleanupCount} items cleaned`)
end

-- ==========================================
-- PLAYER STATE UPDATES
-- ==========================================
function PlayerManager:_updatePlayerStates(currentTime)
	for player, playerData in pairs(self.players) do
		-- Update activity status
		playerData.lastActivity = currentTime

		-- Check and remove temporary restrictions
		if playerData.security.isRestricted and 
			currentTime >= playerData.security.restrictionEnd then
			playerData.security.isRestricted = false
			self.eventBus.emit("restrictionLifted", player)
		end

		-- Update network performance metrics
		self:_updateNetworkMetrics(player, playerData)

		-- Update behavioral analysis
		self:_updateBehavioralAnalysis(player, playerData, currentTime)
	end
end

-- ==========================================
-- VALIDATION QUEUE PROCESSING
-- ==========================================
function PlayerManager:_processValidationQueue()
	local processed = 0
	local maxProcess = Config.PERFORMANCE.BATCH_SIZE

	for queueKey, queueItem in pairs(self.validationQueue) do
		if processed >= maxProcess then break end

		-- Process queued validation
		local success, result = pcall(queueItem.validator, queueItem.context)

		if success then
			queueItem.callback(result)
		else
			queueItem.callback({
				success = false,
				reason = "QUEUE_PROCESSING_ERROR",
				error = result
			})
		end

		-- Remove from queue
		self.validationQueue[queueKey] = nil
		processed = processed + 1
	end
end

-- ==========================================
-- SECURITY MONITORING
-- ==========================================
function PlayerManager:_monitorSecurityThreats(currentTime)
	for player, playerData in pairs(self.players) do
		-- Check for suspicious patterns
		local violations = playerData.security.violations
		local recentViolations = 0
		local cutoff = currentTime - 60 -- Last minute

		for _, violation in ipairs(violations) do
			if violation.timestamp >= cutoff then
				recentViolations = recentViolations + 1
			end
		end

		-- Alert for burst violations
		if recentViolations >= 5 then
			self.eventBus.emit("securityAlert", player, {
				type = "BURST_VIOLATIONS",
				count = recentViolations,
				timeframe = 60
			})
		end

		-- Check for inactive players (potential AFK or bot)
		local timeSinceActivity = currentTime - playerData.lastActivity
		if timeSinceActivity > 300 and playerData.stats.totalShots > 0 then -- 5 minutes
			self.eventBus.emit("securityAlert", player, {
				type = "SUSPICIOUS_INACTIVITY",
				duration = timeSinceActivity
			})
		end
	end
end

-- ==========================================
-- NETWORK METRICS UPDATE
-- ==========================================
function PlayerManager:_updateNetworkMetrics(player, playerData)
	-- Estimate network latency (this would need actual ping implementation)
	-- For now, we'll use a placeholder
	local estimatedLatency = 0.05 -- 50ms default

	-- You would implement actual ping measurement here
	-- This could involve RemoteFunctions or custom ping system

	playerData.performance.networkLatency = estimatedLatency
	playerData.performance.lastPing = os.clock()
end

-- ==========================================
-- BEHAVIORAL ANALYSIS UPDATE
-- ==========================================
function PlayerManager:_updateBehavioralAnalysis(player, playerData, currentTime)
	if not playerData then return end
	local character = player.Character
	if not character or not character:FindFirstChild("HumanoidRootPart") then
		return
	end

	local humanoidRootPart = character.HumanoidRootPart

	-- Track movement patterns
	local currentPos = humanoidRootPart.Position
	local lastMovement = playerData.behavior.movementData[#playerData.behavior.movementData]

	if lastMovement then
		local distance = (currentPos - lastMovement.position).Magnitude
		local timeDelta = currentTime - lastMovement.timestamp

		if timeDelta > 0 then
			local velocity = distance / timeDelta

			-- Add movement data
			table.insert(playerData.behavior.movementData, {
				position = currentPos,
				velocity = velocity,
				timestamp = currentTime
			})

			-- Calculate movement variance for bot detection
			self:_calculateMovementVariance(playerData)
		end
	else
		-- First movement entry
		table.insert(playerData.behavior.movementData, {
			position = currentPos,
			velocity = 0,
			timestamp = currentTime
		})
	end
end

-- ==========================================
-- MOVEMENT VARIANCE CALCULATION
-- ==========================================
function PlayerManager:_calculateMovementVariance(playerData)
	if not playerData then return end
	local movementData = playerData.behavior.movementData
	if #movementData < 10 then return end -- Need enough data

	local velocities = {}
	for i = math.max(1, #movementData - 20), #movementData do
		table.insert(velocities, movementData[i].velocity)
	end

	-- Calculate mean
	local mean = 0
	for _, velocity in ipairs(velocities) do
		mean = mean + velocity
	end
	mean = mean / #velocities

	-- Calculate variance
	local variance = 0
	for _, velocity in ipairs(velocities) do
		variance = variance + (velocity - mean) ^ 2
	end
	variance = variance / #velocities

	playerData.stats.movementVariance = variance

	-- Check for bot-like movement (too consistent)
	if variance < Config.SECURITY.MIN_MOVEMENT_VARIANCE and mean > 0.1 then
		-- Potential bot detected
		self.eventBus.emit("securityAlert", playerData.player, {
			type = "BOT_MOVEMENT_DETECTED",
			variance = variance,
			threshold = Config.SECURITY.MIN_MOVEMENT_VARIANCE
		})
	end
end

-- ==========================================
-- UTILITY FUNCTIONS
-- ==========================================
function PlayerManager:_calculateMemoryUsage()
	-- Estimate memory usage based on data structures
	local totalMemory = 0

	for player, playerData in pairs(self.players) do
		if not playerData then continue end
		-- Rough estimation of memory per player
		totalMemory = totalMemory + 1024 -- Base player data
		totalMemory = totalMemory + (#playerData.security.violations * 256)
		totalMemory = totalMemory + (#playerData.behavior.accuracyHistory * 32)
		totalMemory = totalMemory + (#playerData.behavior.reactionTimes * 32)
		totalMemory = totalMemory + (#playerData.behavior.movementData * 128)
	end

	return totalMemory
end

function PlayerManager:getPlayerCount()
	local count = 0
	for _ in pairs(self.players) do
		count = count + 1
	end
	return count
end

-- ==========================================
-- CLEANUP ON SHUTDOWN
-- ==========================================
function PlayerManager:destroy()
	if self.mainLoopConnection then
		self.mainLoopConnection:Disconnect()
		self.mainLoopConnection = nil
	end

	-- Clear all data
	self.players = {}
	self.validationQueue = {}
	self.eventBus.listeners = {}
end
function PlayerManager:addPlayer(player)
	if self.players[player] then
		warn(`Player {player.Name} already exists in PlayerManager`)
		return false
	end
	
	self.players[player] = {
		-- Core Data
		userId = player.UserId,
		joinTime = os.clock(),
		lastActivity = os.clock(),

		-- Combat State
		combat = {
			activeWeapon = nil,
			weapons = {},
			lastFireTime = 0,
			lastReloadTime = {},
			lastWeaponSwitch = 0,
			isShooting = false,
			isReloading = false,
			isAiming = false
		},

		-- Anti-Cheat Data
		security = {
			violations = {},
			suspicionScore = 0,
			totalViolations = 0,
			lastViolation = 0,
			isRestricted = false,
			restrictionEnd = 0,
			warningsIssued = 0
		},

		-- Statistical Data
		stats = {
			totalShots = 0,
			totalHits = 0,
			headshots = 0,
			accuracy = 0,
			averageReactionTime = 0,
			movementVariance = 0
		},

		-- Behavioral Analysis
		behavior = {
			accuracyHistory = {},
			reactionTimes = {},
			movementData = {},
			shotPatterns = {},
			requestTimings = {}
		},

		-- Performance Tracking
		performance = {
			networkLatency = 0,
			packetLoss = 0,
			lastPing = 0
		},

		-- State Management
		state = {
			isValid = true,
			errors = {},
			lastValidation = 0
		}
	}
	
	-- Initialize weapons
	for weaponName, weaponConfig in pairs(Config.WEAPONS) do
		self.players[player].combat.weapons[weaponName] = {
			ammo = weaponConfig.Ammo,
			CurrentSpreadAngle = weaponConfig.SpreadAngles.SpreadAngle,
			lastReload = 0,
			isReloading = false,
		}
	end
	self.eventBus.emit("playerAdded", player, self.players[player])
	return true
end

function PlayerManager:removePlayer(player)
	if not self.players[player] then return false end

	self.eventBus.emit("playerRemoving", player, self.players[player])
	self.players[player] = nil
	return true
end

function PlayerManager:getPlayer(player)
	return self.players[player]
end

function PlayerManager:updatePlayerData(player, category, field, value)
	local playerData = self.players[player]
	if not playerData then return false end

	if playerData[category] and playerData[category][field] ~= nil then
		local oldValue = playerData[category][field]
		playerData[category][field] = value
		playerData.lastActivity = os.clock()

		self.eventBus.emit("dataUpdated", player, category, field, oldValue, value)
		return true
	end

	return false
end

-- ==========================================
-- VALIDATION PIPELINE SYSTEM
-- ==========================================
local ValidationPipeline = {}
ValidationPipeline.__index = ValidationPipeline

function ValidationPipeline.new(playerManager)
	local self = setmetatable({}, ValidationPipeline)
	self.playerManager = playerManager
	self.validators = {}
	self.cache = {}

	self:_registerDefaultValidators()
	return self
end

function ValidationPipeline:addValidator(name, validator)
	self.validators[name] = validator
end

function ValidationPipeline:validate(player, action, data)
	local startTime = os.clock()
	local playerData = self.playerManager:getPlayer(player)

	if not playerData or not playerData.state.isValid then
		return self:_createResult(false, "INVALID_PLAYER_STATE", nil)
	end

	local context = {
		player = player,
		playerData = playerData,
		action = action,
		data = data,
		timestamp = startTime,
		networkLatency = playerData.performance.networkLatency
	}

	-- Run validation chain
	for validatorName, validator in pairs(self.validators) do
		local success, result = pcall(validator, context)
		if not success then
			warn(`[ValidationPipeline] Error in validator {validatorName}: {result}`)
			return self:_createResult(false, "VALIDATOR_ERROR", validatorName)
		end

		if not result.success then
			self:_handleViolation(player, validatorName, result)
			return result
		end
	end

	-- Update performance metrics
	local validationTime = os.clock() - startTime
	self:_updatePerformanceMetrics(validationTime)

	return self:_createResult(true, "VALIDATION_PASSED", validationTime)
end

function ValidationPipeline:_createResult(success, reason, data)
	return {
		success = success,
		reason = reason,
		data = data,
		timestamp = os.clock()
	}
end

function ValidationPipeline:_handleViolation(player, violationType, result)
	local playerData = self.playerManager:getPlayer(player)
	if not playerData then return end
	
	-- Log violation
	table.insert(playerData.security.violations, {
		type = violationType,
		reason = result.reason,
		data = result.data,
		timestamp = os.clock()
	})

	-- Update security metrics
	playerData.security.totalViolations = playerData.security.totalViolations + 1
	playerData.security.lastViolation = os.clock()

	-- Calculate suspicion score
	self:_updateSuspicionScore(player, violationType)

	-- Emit violation event
	self.playerManager.eventBus.emit("violation", player, violationType, result)
end

function ValidationPipeline:_updateSuspicionScore(player, violationType)
	local playerData = self.playerManager:getPlayer(player)
	if not playerData then return end

	local scores = {
		RAPID_FIRE = 10,
		INVALID_BULLET_ORIGIN = 15,
		AMMO_MANIPULATION = 20,
		SPREAD_MODIFICATION = 25,
		REQUEST_SPAM = 8,
		IMPOSSIBLE_ACCURACY = 30,
		MOVEMENT_BOT = 25
	}

	local scoreIncrease = scores[violationType] or 5
	playerData.security.suspicionScore = playerData.security.suspicionScore + scoreIncrease

	-- Apply time decay
	local timeSinceLastViolation = os.clock() - playerData.security.lastViolation
	if timeSinceLastViolation > Config.SECURITY.VIOLATION_DECAY_TIME then
		playerData.security.suspicionScore = math.max(0, 
			playerData.security.suspicionScore * 0.8)
	end
end

function ValidationPipeline:_registerDefaultValidators()
	-- Rate Limiting Validator
	self:addValidator("rateLimiting", function(context)
		local player = context.player
		local action = context.action
		local playerData = context.playerData
		local now = context.timestamp

		local limits = {
			shoot = Config.SECURITY.MIN_FIRE_INTERVAL,
			reload = Config.SECURITY.MIN_RELOAD_INTERVAL,
			switchWeapon = Config.SECURITY.MIN_WEAPON_SWITCH_INTERVAL,
			stateChange = Config.SECURITY.MIN_STATE_CHANGE_INTERVAL
		}

		local limit = limits[action]
		if not limit then
			return {success = true}
		end

		local lastAction = playerData.behavior.requestTimings[action] or 0
		local timeDelta = now - lastAction

		if timeDelta < (limit - context.networkLatency) then
			return {
				success = false,
				reason = "RATE_LIMIT_EXCEEDED",
				data = {
					action = action,
					timeDelta = timeDelta,
					requiredInterval = limit
				}
			}
		end

		playerData.behavior.requestTimings[action] = now
		return {success = true}
	end)

	-- Fire Rate Validator
	self:addValidator("fireRate", function(context)
		if context.action ~= "shoot" then
			return {success = true}
		end

		local playerData = context.playerData
		local weaponName = context.data.weaponName
		local weaponConfig = Config.WEAPONS[weaponName]

		if not weaponConfig then
			return {
				success = false,
				reason = "UNKNOWN_WEAPON",
				data = {weaponName = weaponName}
			}
		end

		local timeDelta = context.timestamp - playerData.combat.lastFireTime
		local requiredInterval = weaponConfig.FireRate
		
		if timeDelta < (requiredInterval - context.networkLatency) then
			return {
				success = false,
				reason = "RAPID_FIRE",
				data = {
					weaponName = weaponName,
					timeDelta = timeDelta,
					requiredInterval = requiredInterval
				}
			}
		end

		return {success = true}
	end)

	-- Bullet Origin Validator
	self:addValidator("bulletOrigin", function(context)
		if context.action ~= "shoot" then
			return {success = true}
		end

		local player = context.player
		local muzzlePos = context.data.muzzlePos

		if not player.Character then
			return {
				success = false,
				reason = "NO_CHARACTER",
				data = {}
			}
		end

		local validParts = {"Head", "Torso", "Right Arm", "Left Arm"}
		local minDistance = math.huge

		for _, partName in ipairs(validParts) do
			local part = player.Character:FindFirstChild(partName)
			if part then
				local distance = (part.Position - muzzlePos).Magnitude
				minDistance = math.min(minDistance, distance)
			end
		end

		if minDistance > Config.SECURITY.MAX_SHOT_DISTANCE then
			return {
				success = false,
				reason = "INVALID_BULLET_ORIGIN",
				data = {
					muzzlePos = muzzlePos,
					minDistance = minDistance,
					maxAllowed = Config.SECURITY.MAX_SHOT_DISTANCE
				}
			}
		end

		return {success = true}
	end)

	-- Ammo Consistency Validator
	self:addValidator("ammoConsistency", function(context)
		if context.action ~= "shoot" and context.action ~= "reload" then
			return {success = true}
		end

		local playerData = context.playerData
		local weaponName = context.data.weaponName
		local clientAmmo = context.data.ammo

		local serverWeapon = playerData.combat.weapons[weaponName]
		
		if not serverWeapon then
			return {
				success = false,
				reason = "WEAPON_NOT_FOUND",
				data = {server = serverWeapon,unvalidweapon = weaponName}
			}
		end
		
		if not clientAmmo then 
			return {
				success = false,
				reason = "AMMO NOT FOUND"
			}
		end
	
		local ammoDiscrepancy = math.abs(serverWeapon.ammo - clientAmmo)
		
		if ammoDiscrepancy > Config.SECURITY.MAX_AMMO_DISCREPANCY then
			return {
				success = false,
				reason = "AMMO_MANIPULATION",
				data = {
					weaponName = weaponName,
					serverAmmo = serverWeapon.ammo,
					clientAmmo = clientAmmo,
					discrepancy = ammoDiscrepancy
				}
			}
		end

		return {success = true}
	end)

	-- Behavioral Analysis Validator
	self:addValidator("behaviorAnalysis", function(context)
		local playerData = context.playerData
		local behavior = playerData.behavior
		local stats = playerData.stats

		-- Check accuracy
		if #behavior.accuracyHistory > 10 then
			local avgAccuracy = 0
			for _, acc in ipairs(behavior.accuracyHistory) do
				avgAccuracy = avgAccuracy + acc
			end
			avgAccuracy = avgAccuracy / #behavior.accuracyHistory

			if avgAccuracy > Config.SECURITY.MAX_ACCURACY_THRESHOLD then
				return {
					success = false,
					reason = "IMPOSSIBLE_ACCURACY",
					data = {
						accuracy = avgAccuracy,
						threshold = Config.SECURITY.MAX_ACCURACY_THRESHOLD
					}
				}
			end
		end

		-- Check headshot ratio
		if stats.totalShots > 20 and stats.totalHits > 0 then
			local headshotRatio = stats.headshots / stats.totalHits
			if headshotRatio > Config.SECURITY.MAX_HEADSHOT_RATIO then
				return {
					success = false,
					reason = "IMPOSSIBLE_HEADSHOT_RATIO",
					data = {
						ratio = headshotRatio,
						threshold = Config.SECURITY.MAX_HEADSHOT_RATIO
					}
				}
			end
		end

		return {success = true}
	end)
	self:addValidator("changeWeapon", function(context)
		if context.action ~= "changeWeapon" then
			return {success = true}
		end

		local playerData = context.playerData
		local newWeaponName = context.data.weaponName
		local currentWeapon = playerData.combat.activeWeapon
		
		-- Check if weapon exists in config
		local weaponConfig = Config.WEAPONS[newWeaponName]
		if not weaponConfig then
			return {
				success = false,
				reason = "INVALID_WEAPON",
				data = {weaponName = newWeaponName}
			}
		end

		-- Check if player owns this weapon
		local playerWeapon = playerData.combat.weapons[newWeaponName]
		if not playerWeapon then
			return {
				success = false,
				reason = "WEAPON_NOT_OWNED",
				data = {weaponName = newWeaponName}
			}
		end

		-- Check if trying to switch to same weapon
		if currentWeapon == newWeaponName then
			return {
				success = false,
				reason = "REDUNDANT_WEAPON_SWITCH",
				data = {weaponName = newWeaponName}
			}
		end
		playerData.combat.activeWeapon = newWeaponName
		
		return {success = true}
	end)
	self:addValidator("aiming",function(context)
		local playerData = context.playerData
		local weaponName = context.data.weaponName

		if playerData.combat.isReloading then
			return {success = false, reason = "Cannot aim while reloading"}
		end

		-- Weapon checks
		if not weaponName or not playerData.combat.weapons[weaponName] then
			return {success = false, reason = "Invalid weapon"}
		end

		if playerData.combat.activeWeapon ~= weaponName then
			return {success = false, reason = "Weapon not equipped"}
		end

		local weaponConfig = Config.WEAPONS[weaponName]
		if not weaponConfig or not weaponConfig.CanAim then
			return {success = false, reason = "Weapon cannot aim"}
		end

		-- Rate limiting
		local lastAimToggle = playerData.combat.lastAimToggle or 0
		if os.clock() - lastAimToggle < 0.1 then -- 100ms cooldown
			return {success = false, reason = "Aim toggle too rapid"}
		end

		return {success = true}
	end)
	self:addValidator("alivecheck",function(context)
		local player = context.player
		local character = player.Character
		if not character then 
			return {
				success = false,
				reason = "CHARACTER_NOT FOUND"
			}
		end
		local humanoid = character:FindFirstChild("Humanoid")
		if not humanoid then 
			return {
				success = false,
				reason = "HUMANOID_NOT_FOUND"
			}
		end
		if humanoid.Health <= 0 then
			return {
				success = false,
				reason = "HUMANOID_INVALID_HEALTH",
			}
		end
		
		return {success = true}
	end)
end

function ValidationPipeline:_updatePerformanceMetrics(validationTime)
	-- Track performance metrics for optimization
	self.playerManager.performanceMetrics.validationsPerSecond = 
		self.playerManager.performanceMetrics.validationsPerSecond + 1
end

-- ==========================================
-- PUNISHMENT SYSTEM
-- ==========================================
local PunishmentSystem = {}
PunishmentSystem.__index = PunishmentSystem

function PunishmentSystem.new(playerManager)
	local self = setmetatable({}, PunishmentSystem)
	self.playerManager = playerManager

	-- Listen to violation events
	playerManager.eventBus.on("violation", function(player, violationType, result)
		
		self:evaluatePunishment(player)
	end)

	return self
end

function PunishmentSystem:evaluatePunishment(player)
	local playerData = self.playerManager:getPlayer(player)
	if not playerData then return end

	local score = playerData.security.suspicionScore
	local violations = playerData.security.totalViolations

	if score >= Config.SECURITY.PERM_BAN_THRESHOLD then
		self:executePunishment(player, "permanentBan", 0, "Multiple severe violations detected")
	elseif score >= Config.SECURITY.TEMP_BAN_THRESHOLD then
		self:executePunishment(player, "temporaryBan", 3600, "Suspicious activity detected")
	elseif score >= Config.SECURITY.TEMP_RESTRICT_THRESHOLD then
		self:executePunishment(player, "temporaryRestriction", 600, "Multiple violations detected")
	elseif violations >= Config.SECURITY.WARNING_THRESHOLD and 
		playerData.security.warningsIssued < 3 then
		self:executePunishment(player, "warning", 0, "Violation threshold reached")
	end
end

function PunishmentSystem:executePunishment(player, type, duration, reason)
	local playerData = self.playerManager:getPlayer(player)
	if not playerData then return end

	local timestamp = os.clock()

	if type == "warning" then
		playerData.security.warningsIssued = playerData.security.warningsIssued + 1
		-- Send warning to client (implement your UI system)
		print(`[PUNISHMENT] Warning issued to {player.Name}: {reason}`)

	elseif type == "temporaryRestriction" then
		playerData.security.isRestricted = true
		playerData.security.restrictionEnd = timestamp + duration
		print(`[PUNISHMENT] {player.Name} restricted for {duration} seconds: {reason}`)

	elseif type == "temporaryBan" then
		player:Kick(`Temporary ban ({duration/60} minutes): {reason}`)

	elseif type == "permanentBan" then
		player:Kick(`Permanent ban: {reason}`)
	end

	-- Log punishment
	self.playerManager.eventBus.emit("punishment", player, type, duration, reason)
end

-- ==========================================
-- UNIFIED SHOOTING SYSTEM
-- ==========================================
local ShootingSystem = {}
ShootingSystem.__index = ShootingSystem

function ShootingSystem.new(playerManager, validationPipeline)
	local self = setmetatable({}, ShootingSystem)
	self.playerManager = playerManager
	self.validation = validationPipeline

	return self
end
local FastCast = require(ReplicatedStorage.Modules.FastCastRedux)
local caster = FastCast.new()

function ShootingSystem:handleShootRequest(player : Player, muzzlePos, weaponName, direction, ammo)
	local playerData = self.playerManager:getPlayer(player)
	if not playerData then
		return {success = false, reason = "PLAYER_NOT_FOUND"}
	end
	-- Validate request
	local validationResult = self.validation:validate(player, "shoot", {
		muzzlePos = muzzlePos,
		weaponName = weaponName,
		ammo = ammo,
	})

	if not validationResult.success then
		print(validationResult.reason)
		return {success = false, reason = validationResult.reason}
	end

	

	-- Check weapon state
	local weapon = playerData.combat.weapons[weaponName]
	
	if not weapon or weapon.ammo <= 0 then
		return {success = false, reason = "NO_AMMO"}
	end

	-- Check if player can shoot
	if playerData.combat.isReloading or playerData.security.isRestricted then
		return {success = false, reason = "CANNOT_SHOOT"}
	end
	
	direction = self._getSpreadDirection(direction, weapon.CurrentSpreadAngle)
	local hitResult = self:_processBullet(player, muzzlePos, direction, weaponName)
	caster:Fire(muzzlePos,direction,500)
	-- Update player data
	self:_updateAfterShot(player, weaponName, hitResult)

	return {success = true, hitResult = hitResult}
end
function ShootingSystem._getSpreadDirection(baseDirection, spreadAngle)
	local cosTheta = math.cos(math.rad(spreadAngle))
	local z = cosTheta + (1 - cosTheta) * math.random()
	local phi = math.random() * 2 * math.pi
	local sinT = math.sqrt(1 - z * z)
	local x = sinT * math.cos(phi)
	local y = sinT * math.sin(phi)
	local localVec = Vector3.new(x, y, z)
	local rotation = CFrame.lookAt(Vector3.zero, baseDirection)
	return rotation:VectorToWorldSpace(localVec).Unit
end
function ShootingSystem:_processBullet(player, startPos, direction, weaponName)
	local weaponConfig = Config.WEAPONS[weaponName]
	if not weaponConfig then return nil end

	-- Create raycast parameters
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {player.Character}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude

	-- Perform raycast
	local raycastResult = workspace:Raycast(startPos, direction * 500, raycastParams)

	if raycastResult then
		local hitPart = raycastResult.Instance
		local character = hitPart.Parent
		local humanoid = character:FindFirstChild("Humanoid")

		if humanoid then
			local damage = hitPart.Name == "Head" and 
				weaponConfig.Damage.Head or weaponConfig.Damage.Body

			humanoid:TakeDamage(damage)

			return {
				hit = true,
				part = hitPart.Name,
				damage = damage,
				target = character
			}
		end
	end

	return {hit = false}
end
function ShootingSystem:updateWeaponStat(player, weaponName, statType, value)
	-- Input validation
	if not player or not weaponName or not statType or value == nil then
		warn("Invalid parameters for updateWeaponStat")
		return false
	end

	local playerData = self.playerManager:getPlayer(player)
	if not playerData then
		warn("Player data not found:", player.Name)
		return false
	end

	local clientweapon = playerData.combat.weapons[weaponName]
	local serverweapon = Config.WEAPONS[weaponName]
	if not clientweapon or not serverweapon then
		warn("Weapon not found:", weaponName)
		return false
	end

	-- Whitelist allowed stat modifications
	local ALLOWED_STATS = {
		ammo = {type = "number", min = 0, max = serverweapon.MaxAmmo or 100},
		CurrentSpreadAngle = {type = "number", min = serverweapon.SpreadAngles.AimingSpreadAngle, max = serverweapon.SpreadAngles.MaxSpreadAngle},
	}

	local statConfig = ALLOWED_STATS[statType]
	if not statConfig then
		warn("Stat modification not allowed:", statType)
		return false
	end

	-- Type and bounds checking
	if type(value) ~= statConfig.type then
		warn("Invalid value type for", statType, "expected", statConfig.type)
		return false
	end

	value = math.clamp(value, statConfig.min or -math.huge, statConfig.max or math.huge)

	-- Apply the change
	clientweapon[statType] = value

	-- Log for debugging/anti-cheat
	print(string.format("Updated %s.%s to %s for player %s", 
		weaponName, statType, tostring(value), player.Name))

	return true
end
function ShootingSystem:_updateAfterShot(player, weaponName, hitResult)
	local playerData = self.playerManager:getPlayer(player)
	if not playerData then return end

	-- Update weapon ammo
	local weapon = playerData.combat.weapons[weaponName]
	local ammo = weapon.ammo
	self:updateWeaponStat(player,weaponName,"ammo",ammo - 1)
	local weaponConfig = Config.WEAPONS[weaponName]
	local spreadAngles = weaponConfig.SpreadAngles
	local firingspreadangle = spreadAngles.FiringSpreadAngle
	self:updateWeaponStat(player,weaponName,"CurrentSpreadAngle",weapon.CurrentSpreadAngle + firingspreadangle)
	-- Update statistics
	playerData.stats.totalShots = playerData.stats.totalShots + 1
	playerData.combat.lastFireTime = os.clock()

	if hitResult.hit then
		playerData.stats.totalHits = playerData.stats.totalHits + 1

		if hitResult.part == "Head" then
			playerData.stats.headshots = playerData.stats.headshots + 1
		end
	end

	-- Update accuracy history
	local accuracy = playerData.stats.totalHits / playerData.stats.totalShots
	table.insert(playerData.behavior.accuracyHistory, accuracy)

	-- Maintain history limit
	if #playerData.behavior.accuracyHistory > Config.SECURITY.MAX_HISTORY_LENGTH then
		table.remove(playerData.behavior.accuracyHistory, 1)
	end

	playerData.stats.accuracy = accuracy
	task.delay()
end
-- =========================================
-- RELOADING
-- ========================================
function ShootingSystem:handleReloadRequest(player, weaponName, ammo)
	
	local playerData = self.playerManager:getPlayer(player)
	local validation = self.validation:validate(player, "reload", {
		weaponName = weaponName,
		ammo = ammo,
	})

	if validation.success then

		local weapon = playerData.combat.weapons[weaponName]
		-- Start reload process
		weapon.isReloading = true
		-- Complete reload after delay
		task.delay(Config.WEAPONS[weaponName].ReloadingTime, function()
			self:updateWeaponStat(player,weaponName,"ammo",Config.WEAPONS[weaponName].MaxAmmo)
			weapon.isReloading = false
			self.playerManager:updatePlayerData(player, "combat", "isReloading", false)
		end)
	else
		warn("RELOADING_FAILED :", validation.reason)
	end
end
function ShootingSystem:handleAiming(player, isAiming, weaponName)
	local playerData = self.playerManager:getPlayer(player)
	if not playerData then
		warn("Player data not found for:", player.Name)
		return
	end

	-- For stop aiming, we might not have weaponName, so get current weapon
	local currentWeapon = weaponName or playerData.combat.currentWeapon
	if not currentWeapon then
		warn("No weapon specified for aiming action")
		return
	end

	local validation = self.validation:validate(player, isAiming and "startAiming" or "stopAiming", {
		weaponName = currentWeapon
	})

	if not validation.success then
		warn("AIMING_FAILED:", validation.reason)
		return
	end

	local weapon = playerData.combat.weapons[currentWeapon]
	local weaponConfig = Config.WEAPONS[currentWeapon]

	if not weapon or not weaponConfig then
		warn("Weapon or config not found:", currentWeapon)
		return
	end

	local spreadAngles = weaponConfig.SpreadAngles
	local spread = isAiming 
		and (spreadAngles.AimingSpreadAngle or self.SpreadAngle)
		or (spreadAngles.SpreadAngle)
	self:updateWeaponStat(player,weaponName,"CurrentSpreadAngle",spread)
end
-- ==========================================
-- SYSTEM INITIALIZATION
-- ==========================================
function initializeSystem()
	-- Create core systems
	local playerManager = PlayerManager.new()
	local validationPipeline = ValidationPipeline.new(playerManager)
	local punishmentSystem = PunishmentSystem.new(playerManager)
	local shootingSystem = ShootingSystem.new(playerManager, validationPipeline)
	local systems = {
		playerManager = playerManager,
		validationPipeline = validationPipeline,
		punishmentSystem = punishmentSystem,
		shootingSystem = shootingSystem
	}
	-- ==========================================
	-- CORE SYSTEM EVENT LISTENERS
	-- ==========================================

	-- Player Lifecycle Events
	playerManager.eventBus.on("playerAdded", function(player, playerData)
	end)

	playerManager.eventBus.on("playerRemoving", function(player, playerData)
		
	end)
	
	playerManager.eventBus.on("stop aiming",function(...)
		shootingSystem:handleAiming(...)
	end)
	playerManager.eventBus.on("aiming",function(...)
		shootingSystem:handleAiming(...)
	end)
	playerManager.eventBus.on("reload",function(...)
		shootingSystem:handleReloadRequest(...)
	end)
	-- ==========================================
	-- SET UP ROBLOX PLAYER EVENTS
	-- ==========================================
	Players.PlayerAdded:Connect(function(player)
		systems.playerManager:addPlayer(player)
	end)

	Players.PlayerRemoving:Connect(function(player)
		systems.playerManager:removePlayer(player)
	end)

	-- ==========================================
	-- RETURN SYSTEM COMPONENTS
	-- ==========================================
	return systems
end

-- ==========================================
-- HELPER FUNCTIONS FOR EVENT EMISSION
-- ==========================================

-- Function to manually trigger weapon switch event\
local function Reload(player,weaponName)
	
end
local function switchWeapon(playerManager, player, newWeaponName)
	local playerData = playerManager:getPlayer(player)
	if not playerData then return false end

	local oldWeapon = playerData.combat.activeWeapon

	-- Emit the event
	playerManager.eventBus.emit("weaponSwitched", player, oldWeapon, newWeaponName)

	return true
end

-- Function to manually trigger hit event
local function processHit(playerManager, shooter, target, damage, bodyPart)
	local hitData = {
		damage = damage,
		bodyPart = bodyPart,
		timestamp = os.clock(),
		weapon = playerManager:getPlayer(shooter).combat.activeWeapon
	}

	playerManager.eventBus.emit("playerHit", shooter, target, hitData)
end

-- Function to manually trigger reload event
local function completeReload(playerManager, player, weaponName)
	local playerData = playerManager:getPlayer(player)
	if not playerData then return false end

	local weaponConfig = Config.WEAPONS[weaponName]
	if not weaponConfig then return false end

	local newAmmo = weaponConfig.maxAmmo

	playerManager.eventBus.emit("weaponReloaded", player, weaponName, newAmmo)

	return true
end

-- Export initialization and helper functions
return {
	initialize = initializeSystem,
	switchWeapon = switchWeapon,
	processHit = processHit,
	completeReload = completeReload,
	Config = Config,
}
